<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    </head>
    <body style="padding: 20px;">
        <div id="controls" style="width: 260px; padding: 10px; border: 0 solid black;">
            <!-- Year: <input type="text" name="" value=""><br> --> 
                Yes: <input type="text" name="yes" value="1043"><br>
                No: <input type="text" name="no" value="563"><br>
                Maybe: <input type="text" name="maybe" value="510"><br>
                Not Sure: <input type="text" name="notSure" value="175">
        </div>
        <canvas style="border: 0px solid black;" width="300" height="300"></canvas>
        <textarea name="" id="" cols="30" rows="10"></textarea>
    </body>
    <script type="text/javascript">

//====== PIE CHART =====================
        function drawPieChart(context, results, radius, centerX, centerY, stroke, strokeWidth){
            var angles = [];
            var doneAnimation = false;
            var dumpInterval = false;

            //AWW YEAH, using closures!
            function clearFactory(radius, centerX, centerY, stroke, strokeWidth){
                radius *= 1.1; //Some padding to be sure;
                return function(){
                    context.clearRect(centerX - radius, centerY - radius, centerX + radius, centerY + radius);
                }
            };
            var clear = clearFactory(radius, centerX, centerY, stroke, strokeWidth);

            if(stroke === true && strokeWidth){
                strokeWidth = Math.max(strokeWidth, 40);
                radius = radius - (strokeWidth/2);
            }

            //First element starts at 90 degrees
            var startAngle = (-0.5 * Math.PI);
            var endAngle;
            var total = results.reduce(function(sum, choice) {return sum + choice.count;}, 0);
            
            for(var i = 0; i < results.length; i++){
                var sliceAngle = (results[i].count / total) * 2 * Math.PI;
                endAngle = startAngle + sliceAngle;
                angles.push({startAngle: startAngle, endAngle: endAngle});
                startAngle = endAngle;
            }

            angles.forEach(function(result, index){
                var color = results[index].color;
                var difference = result.endAngle - result.startAngle;
                var step = Math.max(0.05, difference * 0.05);
                var startAngle = result.startAngle - (30*(Math.PI/180));
                var endAngle = startAngle;
            
                var interval = setInterval(function(){
                    if(index == 0){
                        //In a new chain, if all elements are done animating
                        if(doneAnimation)
                            //Initiate dump of the interval
                            dumpInterval = true;
                        else
                            clear();
                    }                    

                    if(dumpInterval){
                        clearInterval(interval);
                    }
                    else {
                        context.save();
                        context.translate(centerX, centerY);     
                        context.beginPath();
                        context.arc(0,0, radius, Math.min(startAngle, result.startAngle), Math.min(endAngle, result.endAngle));
                        
                        if(stroke === true){
                            context.strokeStyle = color;
                            context.lineWidth = strokeWidth;
                            context.stroke();
                        } else {
                            context.lineTo(0,0);
                            context.fillStyle = color;
                            context.fill();
                        }

                        context.restore();
                    
                        if(endAngle >= result.endAngle 
                        && startAngle >= result.startAngle){
                            //First element start the verification chain
                            if(index == 0)
                                doneAnimation = true;
                            else
                            //All other following elements continue the verification
                                doneAnimation = doneAnimation && true;
                        }
                        else {
                            doneAnimation = false;
                            startAngle += step/2;
                            endAngle += step;
                        }
                    }
                }, 30);
            });
        }
//========== END OF PIE DRAWING PART ========

        var context = document.querySelector("canvas").getContext("2d");
        var inputs = document.querySelectorAll("input");
        var controls = document.getElementById("controls");
        var dataModified = false;

        //FOCUS
        controls.addEventListener("click", function(event){
            if(event.target.nodeName == "INPUT")
                controls.style.boxShadow = "0 0 20px lightblue";
                dataModified = true;
        });

        //UNFOCUS
        document.addEventListener("click", function(event){
            if(event.target != controls
            && event.target.parentNode != controls
            && dataModified){
                clearShadowAndRedrawChart();
            }
        })

        //KEYBOARD INPUT
        controls.addEventListener("keydown", function(event){
            //'Save' i.e. redraw the chart
            if(event.key == "Enter" || event.key == "Escape"){
                event.preventDefault();
                event.target.blur();
                clearShadowAndRedrawChart();
            }
            //Traverse through the inputs
            else if(event.key == "Tab"){
                //Last element; Shift NOT pressed
                if(!event.shiftKey && event.target == inputs[inputs.length - 1]){
                    inputs[0].focus();
                    event.preventDefault();
                }
                //First element; Shift pressed
                else if(event.shiftKey && event.target == inputs[0]){
                    inputs[inputs.length - 1].focus();
                    event.preventDefault();
                }
                //Otherwise, operate as normal
            }
            //Only allow permitted input
            else if(!/(\d|\.|Tab|Backspace|Up|ArrowLeft|ArrowRight)/.test(event.key)){
                event.preventDefault();
            }
        })
        
        //TEMPORARY HACK!!
        function clearShadowAndRedrawChart(){
            for(var i = 0; i < inputs.length; i++){
                results[inputs[i].getAttribute("name")].count = parseInt(inputs[i].value);
            }
            controls.style.boxShadow = "";
            dataModified = false;
            drawPieChart(context, convertData(results), 100, 150, 150, true, 28);
        }

        //TEMPORARY HACK!!
        function convertData(data){
            var result = [];
            var names = Object.getOwnPropertyNames(data);
            names.forEach(function(name){
                result.push({name:name, count: data[name].count, color: data[name].color});
            });
            return result;
        }

        //MAIN    
        var results = {
            yes:{count: 1043, color: "lightblue"},
            no:{count: 563, color: "lightgreen"},
            maybe:{count: 510, color: "pink"},
            notSure:{count: 175, color: "silver"}
        };

        drawPieChart(context, convertData(results), 100, 150, 150, true, 28);
    </script>
</html>